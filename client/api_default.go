/*
Alldebrid API

Welcome to the OpenAPI Alldebrid API v4 !<br /> You can use this API to access various Alldebrid services from custom applications or scripts.<br /> <br /> API is organized around REST,<br /> returns JSON-encoded responses and use standard HTTP response codes.<br /> <br /> All calls are to be made on the HTTPS endpoints.<br /> Some are public, others require to be authentificated with an apikey (see Authentication).<br /> <br /> You must also identify your apps or script with a meaningfull agent parameter.<br /> <br /> This API version is namespaced as v4, as such all endpoint start with /v4/,<br /> such like http://api.alldebrid.com/v4/ping?agent=apiShowcase.<br /> <br /> This API v4 should be the final version regarding general response format and errors (hopefully).<br />

API version: 4.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"os"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiHostsDomainsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
}

// Your software user-agent.
func (r ApiHostsDomainsGetRequest) Agent(agent string) ApiHostsDomainsGetRequest {
	r.agent = &agent
	return r
}

func (r ApiHostsDomainsGetRequest) Execute() (*HostsDomainsGet200Response, *http.Response, error) {
	return r.ApiService.HostsDomainsGetExecute(r)
}

/*
HostsDomainsGet Use this endpoint to only retrieve the list of supported hosts domains and redirectors as an array.

Use this endpoint to only retrieve the list of supported hosts domains and redirectors as an array.<br /> <br /> This will also include any alternative domain the hosts or redirectors have.<br /> Please use regexps availables in /hosts or /user/hosts endpoints to validate supported links.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHostsDomainsGetRequest
*/
func (a *DefaultAPIService) HostsDomainsGet(ctx context.Context) ApiHostsDomainsGetRequest {
	return ApiHostsDomainsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HostsDomainsGet200Response
func (a *DefaultAPIService) HostsDomainsGetExecute(r ApiHostsDomainsGetRequest) (*HostsDomainsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HostsDomainsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.HostsDomainsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hosts/domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHostsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	hostOnly *string
}

// Your software user-agent.
func (r ApiHostsGetRequest) Agent(agent string) ApiHostsGetRequest {
	r.agent = &agent
	return r
}

// Endpoint will only return \&quot;hosts\&quot; data
func (r ApiHostsGetRequest) HostOnly(hostOnly string) ApiHostsGetRequest {
	r.hostOnly = &hostOnly
	return r
}

func (r ApiHostsGetRequest) Execute() (*HostsGet200Response, *http.Response, error) {
	return r.ApiService.HostsGetExecute(r)
}

/*
HostsGet Use this endpoint to retrieve informations about what hosts we support.

Use this endpoint to retrieve informations about what hosts we support and all related informations about it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHostsGetRequest
*/
func (a *DefaultAPIService) HostsGet(ctx context.Context) ApiHostsGetRequest {
	return ApiHostsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HostsGet200Response
func (a *DefaultAPIService) HostsGetExecute(r ApiHostsGetRequest) (*HostsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HostsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.HostsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	if r.hostOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostOnly", r.hostOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHostsPriorityGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
}

// Your software user-agent.
func (r ApiHostsPriorityGetRequest) Agent(agent string) ApiHostsPriorityGetRequest {
	r.agent = &agent
	return r
}

func (r ApiHostsPriorityGetRequest) Execute() (*HostsPriorityGet200Response, *http.Response, error) {
	return r.ApiService.HostsPriorityGetExecute(r)
}

/*
HostsPriorityGet Not all hosts are created equal, so some hosts are more limited than other.

Use this endpoint to retrieve an ordered list of main domain of hosts, from more open to more restricted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHostsPriorityGetRequest
*/
func (a *DefaultAPIService) HostsPriorityGet(ctx context.Context) ApiHostsPriorityGetRequest {
	return ApiHostsPriorityGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HostsPriorityGet200Response
func (a *DefaultAPIService) HostsPriorityGetExecute(r ApiHostsPriorityGetRequest) (*HostsPriorityGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HostsPriorityGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.HostsPriorityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hosts/priority"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkDelayedGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	id *string
	apikey *string
}

// Your software user-agent.
func (r ApiLinkDelayedGetRequest) Agent(agent string) ApiLinkDelayedGetRequest {
	r.agent = &agent
	return r
}

// Delayed ID received in /link/unlock.
func (r ApiLinkDelayedGetRequest) Id(id string) ApiLinkDelayedGetRequest {
	r.id = &id
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkDelayedGetRequest) Apikey(apikey string) ApiLinkDelayedGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiLinkDelayedGetRequest) Execute() (*LinkDelayedGet200Response, *http.Response, error) {
	return r.ApiService.LinkDelayedGetExecute(r)
}

/*
LinkDelayedGet This endpoint give the status of a delayed link.

This endpoint give the status of a delayed link.<br /> <br /> Some links need time to generate, this endpoint send the status of such delayed links.<br /> <br /> You should pool every 5 seconds or more the link/delayed endpoint until given the download link.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkDelayedGetRequest
*/
func (a *DefaultAPIService) LinkDelayedGet(ctx context.Context) ApiLinkDelayedGetRequest {
	return ApiLinkDelayedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LinkDelayedGet200Response
func (a *DefaultAPIService) LinkDelayedGetExecute(r ApiLinkDelayedGetRequest) (*LinkDelayedGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkDelayedGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LinkDelayedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/delayed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkInfosGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	link *[]string
	apikey *string
	password *string
}

// Your software user-agent.
func (r ApiLinkInfosGetRequest) Agent(agent string) ApiLinkInfosGetRequest {
	r.agent = &agent
	return r
}

// The link or array of links you request informations about.
func (r ApiLinkInfosGetRequest) Link(link []string) ApiLinkInfosGetRequest {
	r.link = &link
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkInfosGetRequest) Apikey(apikey string) ApiLinkInfosGetRequest {
	r.apikey = &apikey
	return r
}

// Link password (supported on uptobox / 1fichier).
func (r ApiLinkInfosGetRequest) Password(password string) ApiLinkInfosGetRequest {
	r.password = &password
	return r
}

func (r ApiLinkInfosGetRequest) Execute() (*LinkInfosGet200Response, *http.Response, error) {
	return r.ApiService.LinkInfosGetExecute(r)
}

/*
LinkInfosGet Use this endpoint to retrieve informations about a link.

Use this endpoint to retrieve informations about a link.<br /> If it is in our systems, you'll have the filename and size (if available).<br /> <br /> If the host is not supported or the link is down, an error will be<br /> returned for that link.<br /> <br /> This endpoint only support host links, not redirectors links. Use the<br /> link/redirector endpoint for this.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkInfosGetRequest
*/
func (a *DefaultAPIService) LinkInfosGet(ctx context.Context) ApiLinkInfosGetRequest {
	return ApiLinkInfosGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LinkInfosGet200Response
func (a *DefaultAPIService) LinkInfosGetExecute(r ApiLinkInfosGetRequest) (*LinkInfosGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkInfosGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LinkInfosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/infos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	}
	{
		t := *r.link
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkRedirectorGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	link *string
	apikey *string
}

// Your software user-agent.
func (r ApiLinkRedirectorGetRequest) Agent(agent string) ApiLinkRedirectorGetRequest {
	r.agent = &agent
	return r
}

// The redirector or protector link to extract links.
func (r ApiLinkRedirectorGetRequest) Link(link string) ApiLinkRedirectorGetRequest {
	r.link = &link
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkRedirectorGetRequest) Apikey(apikey string) ApiLinkRedirectorGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiLinkRedirectorGetRequest) Execute() (*LinkRedirectorGet200Response, *http.Response, error) {
	return r.ApiService.LinkRedirectorGetExecute(r)
}

/*
LinkRedirectorGet Use this endpoint to retrieve links protected by a redirector or link protector.

Use this endpoint to retrieve links protected by a redirector or link protector.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkRedirectorGetRequest
*/
func (a *DefaultAPIService) LinkRedirectorGet(ctx context.Context) ApiLinkRedirectorGetRequest {
	return ApiLinkRedirectorGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LinkRedirectorGet200Response
func (a *DefaultAPIService) LinkRedirectorGetExecute(r ApiLinkRedirectorGetRequest) (*LinkRedirectorGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkRedirectorGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LinkRedirectorGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/redirector"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "link", r.link, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkStreamingGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	id *string
	stream *string
	apikey *string
}

// Your software user-agent.
func (r ApiLinkStreamingGetRequest) Agent(agent string) ApiLinkStreamingGetRequest {
	r.agent = &agent
	return r
}

// The link ID you received from the /link/unlock call.
func (r ApiLinkStreamingGetRequest) Id(id string) ApiLinkStreamingGetRequest {
	r.id = &id
	return r
}

// The stream ID you choosed from the stream qualities list returned by /link/unlock.
func (r ApiLinkStreamingGetRequest) Stream(stream string) ApiLinkStreamingGetRequest {
	r.stream = &stream
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkStreamingGetRequest) Apikey(apikey string) ApiLinkStreamingGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiLinkStreamingGetRequest) Execute() (*LinkStreamingGet200Response, *http.Response, error) {
	return r.ApiService.LinkStreamingGetExecute(r)
}

/*
LinkStreamingGet The unlocking flow for streaming link is a bit more complex.

First hit the usual link/unlock endpoint. Two cases:<br /> <br /> Stream link has only one quality : downloading link is available immediatly.<br /> <br /> OR<br /> <br /> Stream links has multiple qualities : you must select the desired<br /> quality to obtain a download link or delayed id by using the<br /> link/streaming endpoint.<br /> <br /> Depending of the stream website, you'll either get a download link, or a<br /> delayed id (see Delayed link section for delayed links).<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkStreamingGetRequest
*/
func (a *DefaultAPIService) LinkStreamingGet(ctx context.Context) ApiLinkStreamingGetRequest {
	return ApiLinkStreamingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LinkStreamingGet200Response
func (a *DefaultAPIService) LinkStreamingGetExecute(r ApiLinkStreamingGetRequest) (*LinkStreamingGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkStreamingGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LinkStreamingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/streaming"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.stream == nil {
		return localVarReturnValue, nil, reportError("stream is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "stream", r.stream, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkUnlockGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	link *string
	apikey *string
	password *string
}

// Your software user-agent.
func (r ApiLinkUnlockGetRequest) Agent(agent string) ApiLinkUnlockGetRequest {
	r.agent = &agent
	return r
}

// The redirector or protector link to extract links.
func (r ApiLinkUnlockGetRequest) Link(link string) ApiLinkUnlockGetRequest {
	r.link = &link
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiLinkUnlockGetRequest) Apikey(apikey string) ApiLinkUnlockGetRequest {
	r.apikey = &apikey
	return r
}

// Link password (supported on uptobox / 1fichier).
func (r ApiLinkUnlockGetRequest) Password(password string) ApiLinkUnlockGetRequest {
	r.password = &password
	return r
}

func (r ApiLinkUnlockGetRequest) Execute() (*LinkUnlockGet200Response, *http.Response, error) {
	return r.ApiService.LinkUnlockGetExecute(r)
}

/*
LinkUnlockGet This endpoint unlocks a given link.

This endpoint can return a delayed ID. In that case, you must follow the delayed link flow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkUnlockGetRequest
*/
func (a *DefaultAPIService) LinkUnlockGet(ctx context.Context) ApiLinkUnlockGetRequest {
	return ApiLinkUnlockGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LinkUnlockGet200Response
func (a *DefaultAPIService) LinkUnlockGetExecute(r ApiLinkUnlockGetRequest) (*LinkUnlockGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkUnlockGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LinkUnlockGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/link/unlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "link", r.link, "")
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetDeleteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	id *string
	apikey *string
}

// Your software user-agent.
func (r ApiMagnetDeleteGetRequest) Agent(agent string) ApiMagnetDeleteGetRequest {
	r.agent = &agent
	return r
}

// Magnet ID.
func (r ApiMagnetDeleteGetRequest) Id(id string) ApiMagnetDeleteGetRequest {
	r.id = &id
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetDeleteGetRequest) Apikey(apikey string) ApiMagnetDeleteGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetDeleteGetRequest) Execute() (*MagnetDeleteGet200Response, *http.Response, error) {
	return r.ApiService.MagnetDeleteGetExecute(r)
}

/*
MagnetDeleteGet Delete a magnet.

Delete a magnet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetDeleteGetRequest
*/
func (a *DefaultAPIService) MagnetDeleteGet(ctx context.Context) ApiMagnetDeleteGetRequest {
	return ApiMagnetDeleteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MagnetDeleteGet200Response
func (a *DefaultAPIService) MagnetDeleteGetExecute(r ApiMagnetDeleteGetRequest) (*MagnetDeleteGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MagnetDeleteGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MagnetDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetInstantGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	magnets *[]string
	apikey *string
}

// Your software user-agent.
func (r ApiMagnetInstantGetRequest) Agent(agent string) ApiMagnetInstantGetRequest {
	r.agent = &agent
	return r
}

// Magnets URI or hash you wish to check instant availability, can be one or many links
func (r ApiMagnetInstantGetRequest) Magnets(magnets []string) ApiMagnetInstantGetRequest {
	r.magnets = &magnets
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetInstantGetRequest) Apikey(apikey string) ApiMagnetInstantGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetInstantGetRequest) Execute() (*MagnetInstantGet200Response, *http.Response, error) {
	return r.ApiService.MagnetInstantGetExecute(r)
}

/*
MagnetInstantGet Check if a magnet is available instantly.

Check if a magnet is available instantly.<br /> You can either send the magnets in GET parameters, or in POST.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetInstantGetRequest
*/
func (a *DefaultAPIService) MagnetInstantGet(ctx context.Context) ApiMagnetInstantGetRequest {
	return ApiMagnetInstantGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MagnetInstantGet200Response
func (a *DefaultAPIService) MagnetInstantGetExecute(r ApiMagnetInstantGetRequest) (*MagnetInstantGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MagnetInstantGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MagnetInstantGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/instant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.magnets == nil {
		return localVarReturnValue, nil, reportError("magnets is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	{
		t := *r.magnets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "magnets[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "magnets[]", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetRestartGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	id *string
	apikey *string
}

// Your software user-agent.
func (r ApiMagnetRestartGetRequest) Agent(agent string) ApiMagnetRestartGetRequest {
	r.agent = &agent
	return r
}

// Magnet ID
func (r ApiMagnetRestartGetRequest) Id(id string) ApiMagnetRestartGetRequest {
	r.id = &id
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetRestartGetRequest) Apikey(apikey string) ApiMagnetRestartGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetRestartGetRequest) Execute() (*MagnetRestartGet200Response, *http.Response, error) {
	return r.ApiService.MagnetRestartGetExecute(r)
}

/*
MagnetRestartGet Restart a failed magnet, or multiple failed magnets at once.

Restart a failed magnet, or multiple failed magnets at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetRestartGetRequest
*/
func (a *DefaultAPIService) MagnetRestartGet(ctx context.Context) ApiMagnetRestartGetRequest {
	return ApiMagnetRestartGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MagnetRestartGet200Response
func (a *DefaultAPIService) MagnetRestartGetExecute(r ApiMagnetRestartGetRequest) (*MagnetRestartGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MagnetRestartGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MagnetRestartGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/restart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	apikey *string
	id *string
	status *string
	session *string
	counter *string
}

// Your software user-agent.
func (r ApiMagnetStatusGetRequest) Agent(agent string) ApiMagnetStatusGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetStatusGetRequest) Apikey(apikey string) ApiMagnetStatusGetRequest {
	r.apikey = &apikey
	return r
}

// Magnet ID.
func (r ApiMagnetStatusGetRequest) Id(id string) ApiMagnetStatusGetRequest {
	r.id = &id
	return r
}

// Magnets status filter. Either active, ready, expired or error
func (r ApiMagnetStatusGetRequest) Status(status string) ApiMagnetStatusGetRequest {
	r.status = &status
	return r
}

// Session ID for Live mode (see Live Mode).
func (r ApiMagnetStatusGetRequest) Session(session string) ApiMagnetStatusGetRequest {
	r.session = &session
	return r
}

// Counter for Live mode (see Live Mode).
func (r ApiMagnetStatusGetRequest) Counter(counter string) ApiMagnetStatusGetRequest {
	r.counter = &counter
	return r
}

func (r ApiMagnetStatusGetRequest) Execute() (*MagnetStatusGet200Response, *http.Response, error) {
	return r.ApiService.MagnetStatusGetExecute(r)
}

/*
MagnetStatusGet Get the status of current magnets, or only one if you specify a magnet ID.

Get the status of current magnets, or only one if you specify a magnet ID.<br /> !TODO: Add live magnet status.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetStatusGetRequest
*/
func (a *DefaultAPIService) MagnetStatusGet(ctx context.Context) ApiMagnetStatusGetRequest {
	return ApiMagnetStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MagnetStatusGet200Response
func (a *DefaultAPIService) MagnetStatusGetExecute(r ApiMagnetStatusGetRequest) (*MagnetStatusGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MagnetStatusGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MagnetStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.session != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "session", r.session, "")
	}
	if r.counter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "counter", r.counter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetUploadFilePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	apikey *string
	files *os.File
}

// Your software user-agent.
func (r ApiMagnetUploadFilePostRequest) Agent(agent string) ApiMagnetUploadFilePostRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetUploadFilePostRequest) Apikey(apikey string) ApiMagnetUploadFilePostRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetUploadFilePostRequest) Files(files *os.File) ApiMagnetUploadFilePostRequest {
	r.files = files
	return r
}

func (r ApiMagnetUploadFilePostRequest) Execute() (*MagnetUploadFilePost200Response, *http.Response, error) {
	return r.ApiService.MagnetUploadFilePostExecute(r)
}

/*
MagnetUploadFilePost Upload torrent files.

Upload torrent files.<br /> This endpoint should be POSTed on.<br /> It expects a multipart formdata file upload.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetUploadFilePostRequest
*/
func (a *DefaultAPIService) MagnetUploadFilePost(ctx context.Context) ApiMagnetUploadFilePostRequest {
	return ApiMagnetUploadFilePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MagnetUploadFilePost200Response
func (a *DefaultAPIService) MagnetUploadFilePostExecute(r ApiMagnetUploadFilePostRequest) (*MagnetUploadFilePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MagnetUploadFilePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MagnetUploadFilePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/upload/file"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var filesLocalVarFormFileName string
	var filesLocalVarFileName     string
	var filesLocalVarFileBytes    []byte

	filesLocalVarFormFileName = "files[]"
	filesLocalVarFile := r.files

	if filesLocalVarFile != nil {
		fbs, _ := io.ReadAll(filesLocalVarFile)

		filesLocalVarFileBytes = fbs
		filesLocalVarFileName = filesLocalVarFile.Name()
		filesLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: filesLocalVarFileBytes, fileName: filesLocalVarFileName, formFileName: filesLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMagnetUploadGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	magnets *[]string
	apikey *string
}

// Your software user-agent.
func (r ApiMagnetUploadGetRequest) Agent(agent string) ApiMagnetUploadGetRequest {
	r.agent = &agent
	return r
}

// Magnet(s) URI or hash. Must send magnet either in GET param or in POST data.
func (r ApiMagnetUploadGetRequest) Magnets(magnets []string) ApiMagnetUploadGetRequest {
	r.magnets = &magnets
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiMagnetUploadGetRequest) Apikey(apikey string) ApiMagnetUploadGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiMagnetUploadGetRequest) Execute() (*MagnetUploadGet200Response, *http.Response, error) {
	return r.ApiService.MagnetUploadGetExecute(r)
}

/*
MagnetUploadGet Upload a magnet with its URI or hash.

Upload a magnet with its URI or hash.<br /> You can either send the magnets in GET parameters, or in POST.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMagnetUploadGetRequest
*/
func (a *DefaultAPIService) MagnetUploadGet(ctx context.Context) ApiMagnetUploadGetRequest {
	return ApiMagnetUploadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MagnetUploadGet200Response
func (a *DefaultAPIService) MagnetUploadGetExecute(r ApiMagnetUploadGetRequest) (*MagnetUploadGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MagnetUploadGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MagnetUploadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/magnet/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.magnets == nil {
		return localVarReturnValue, nil, reportError("magnets is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	{
		t := *r.magnets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "magnets[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "magnets[]", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserGetRequest) Agent(agent string) ApiUserGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserGetRequest) Apikey(apikey string) ApiUserGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserGetRequest) Execute() (*UserGet200Response, *http.Response, error) {
	return r.ApiService.UserGetExecute(r)
}

/*
UserGet Use this endpoint to get user informations.

Use this endpoint to get user informations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserGetRequest
*/
func (a *DefaultAPIService) UserGet(ctx context.Context) ApiUserGetRequest {
	return ApiUserGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserGet200Response
func (a *DefaultAPIService) UserGetExecute(r ApiUserGetRequest) (*UserGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UserGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserHistoryDeleteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserHistoryDeleteGetRequest) Agent(agent string) ApiUserHistoryDeleteGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserHistoryDeleteGetRequest) Apikey(apikey string) ApiUserHistoryDeleteGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserHistoryDeleteGetRequest) Execute() (*UserHistoryDeleteGet200Response, *http.Response, error) {
	return r.ApiService.UserHistoryDeleteGetExecute(r)
}

/*
UserHistoryDeleteGet Use this endpoint to delete all links currently in your recent links history.

Use this endpoint to delete all links currently in your recent links history.<br /> Links older than 3 days are automatically deleted from the recent history.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserHistoryDeleteGetRequest
*/
func (a *DefaultAPIService) UserHistoryDeleteGet(ctx context.Context) ApiUserHistoryDeleteGetRequest {
	return ApiUserHistoryDeleteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserHistoryDeleteGet200Response
func (a *DefaultAPIService) UserHistoryDeleteGetExecute(r ApiUserHistoryDeleteGetRequest) (*UserHistoryDeleteGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserHistoryDeleteGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UserHistoryDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/history/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserHistoryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserHistoryGetRequest) Agent(agent string) ApiUserHistoryGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserHistoryGetRequest) Apikey(apikey string) ApiUserHistoryGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserHistoryGetRequest) Execute() (*UserLinksGet200Response, *http.Response, error) {
	return r.ApiService.UserHistoryGetExecute(r)
}

/*
UserHistoryGet Use this endpoint to get recent links.

Use this endpoint to get recent links.<br /> Recent link logging being disabled by default,<br /> this will return nothing until history logging has been activated in your account settings.<br /> <br /> Links older than 3 days are automatically deleted from the recent history.<br /> To keep links in your account, use the Saved links.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserHistoryGetRequest
*/
func (a *DefaultAPIService) UserHistoryGet(ctx context.Context) ApiUserHistoryGetRequest {
	return ApiUserHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserLinksGet200Response
func (a *DefaultAPIService) UserHistoryGetExecute(r ApiUserHistoryGetRequest) (*UserLinksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserLinksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UserHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserHostsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	apikey *string
	hostOnly *string
}

// Your software user-agent.
func (r ApiUserHostsGetRequest) Agent(agent string) ApiUserHostsGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserHostsGetRequest) Apikey(apikey string) ApiUserHostsGetRequest {
	r.apikey = &apikey
	return r
}

// Endpoint will only return \&quot;hosts\&quot; data
func (r ApiUserHostsGetRequest) HostOnly(hostOnly string) ApiUserHostsGetRequest {
	r.hostOnly = &hostOnly
	return r
}

func (r ApiUserHostsGetRequest) Execute() (*HostsGet200Response, *http.Response, error) {
	return r.ApiService.UserHostsGetExecute(r)
}

/*
UserHostsGet This endpoint retrieves a complete list of all available hosts for this user.

This endpoint retrieves a complete list of all available hosts for this user.<br /> Depending of the account subscription status (free user, trial mode, premium user),<br /> the list and limitations will vary.<br /> <br /> The limits and quota are updated in real time. Use this page to have an<br /> up-to-date list of service the user can use on Alldebrid.<br /> <br /> Quotas will reset every day for premium users.<br />

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserHostsGetRequest
*/
func (a *DefaultAPIService) UserHostsGet(ctx context.Context) ApiUserHostsGetRequest {
	return ApiUserHostsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HostsGet200Response
func (a *DefaultAPIService) UserHostsGetExecute(r ApiUserHostsGetRequest) (*HostsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HostsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UserHostsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/hosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	if r.hostOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostOnly", r.hostOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLinksDeleteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	apikey *string
	link *string
	link2 *[]string
}

// Your software user-agent.
func (r ApiUserLinksDeleteGetRequest) Agent(agent string) ApiUserLinksDeleteGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserLinksDeleteGetRequest) Apikey(apikey string) ApiUserLinksDeleteGetRequest {
	r.apikey = &apikey
	return r
}

// Link to delete.
func (r ApiUserLinksDeleteGetRequest) Link(link string) ApiUserLinksDeleteGetRequest {
	r.link = &link
	return r
}

// Links to delete.
func (r ApiUserLinksDeleteGetRequest) Link2(link2 []string) ApiUserLinksDeleteGetRequest {
	r.link2 = &link2
	return r
}

func (r ApiUserLinksDeleteGetRequest) Execute() (*UserLinksDeleteGet200Response, *http.Response, error) {
	return r.ApiService.UserLinksDeleteGetExecute(r)
}

/*
UserLinksDeleteGet Delete a saved link.

Delete a saved link.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserLinksDeleteGetRequest
*/
func (a *DefaultAPIService) UserLinksDeleteGet(ctx context.Context) ApiUserLinksDeleteGetRequest {
	return ApiUserLinksDeleteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserLinksDeleteGet200Response
func (a *DefaultAPIService) UserLinksDeleteGetExecute(r ApiUserLinksDeleteGetRequest) (*UserLinksDeleteGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserLinksDeleteGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UserLinksDeleteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/links/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	if r.link != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "link", r.link, "")
	}
	if r.link2 != nil {
		t := *r.link2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLinksGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserLinksGetRequest) Agent(agent string) ApiUserLinksGetRequest {
	r.agent = &agent
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserLinksGetRequest) Apikey(apikey string) ApiUserLinksGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserLinksGetRequest) Execute() (*UserLinksGet200Response, *http.Response, error) {
	return r.ApiService.UserLinksGetExecute(r)
}

/*
UserLinksGet Use this endpoint to get links the user saved for later use.

Use this endpoint to get links the user saved for later use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserLinksGetRequest
*/
func (a *DefaultAPIService) UserLinksGet(ctx context.Context) ApiUserLinksGetRequest {
	return ApiUserLinksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserLinksGet200Response
func (a *DefaultAPIService) UserLinksGetExecute(r ApiUserLinksGetRequest) (*UserLinksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserLinksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UserLinksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLinksSaveGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	link *[]string
	apikey *string
}

// Your software user-agent.
func (r ApiUserLinksSaveGetRequest) Agent(agent string) ApiUserLinksSaveGetRequest {
	r.agent = &agent
	return r
}

// Links to save.
func (r ApiUserLinksSaveGetRequest) Link(link []string) ApiUserLinksSaveGetRequest {
	r.link = &link
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserLinksSaveGetRequest) Apikey(apikey string) ApiUserLinksSaveGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserLinksSaveGetRequest) Execute() (*UserLinksSaveGet200Response, *http.Response, error) {
	return r.ApiService.UserLinksSaveGetExecute(r)
}

/*
UserLinksSaveGet Save a link.

Save a link.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserLinksSaveGetRequest
*/
func (a *DefaultAPIService) UserLinksSaveGet(ctx context.Context) ApiUserLinksSaveGetRequest {
	return ApiUserLinksSaveGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserLinksSaveGet200Response
func (a *DefaultAPIService) UserLinksSaveGetExecute(r ApiUserLinksSaveGetRequest) (*UserLinksSaveGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserLinksSaveGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UserLinksSaveGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/links/save"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.link == nil {
		return localVarReturnValue, nil, reportError("link is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	{
		t := *r.link
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "link[]", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserNotificationClearGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	agent *string
	code *string
	apikey *string
}

// Your software user-agent.
func (r ApiUserNotificationClearGetRequest) Agent(agent string) ApiUserNotificationClearGetRequest {
	r.agent = &agent
	return r
}

// Notification code to clear
func (r ApiUserNotificationClearGetRequest) Code(code string) ApiUserNotificationClearGetRequest {
	r.code = &code
	return r
}

// Deprecated User apikey (Use Bearer Auth in header).
func (r ApiUserNotificationClearGetRequest) Apikey(apikey string) ApiUserNotificationClearGetRequest {
	r.apikey = &apikey
	return r
}

func (r ApiUserNotificationClearGetRequest) Execute() (*UserNotificationClearGet200Response, *http.Response, error) {
	return r.ApiService.UserNotificationClearGetExecute(r)
}

/*
UserNotificationClearGet This endpoint clears a user notification with its code.

This endpoint clears a user notification with its code. Current notifications codes can be retreive from the /user endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserNotificationClearGetRequest
*/
func (a *DefaultAPIService) UserNotificationClearGet(ctx context.Context) ApiUserNotificationClearGetRequest {
	return ApiUserNotificationClearGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserNotificationClearGet200Response
func (a *DefaultAPIService) UserNotificationClearGetExecute(r ApiUserNotificationClearGetRequest) (*UserNotificationClearGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserNotificationClearGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UserNotificationClearGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/notification/clear"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.agent == nil {
		return localVarReturnValue, nil, reportError("agent is required and must be specified")
	}
	if r.code == nil {
		return localVarReturnValue, nil, reportError("code is required and must be specified")
	}

	if r.apikey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apikey", r.apikey, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "agent", r.agent, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
